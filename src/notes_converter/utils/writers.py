"""A module containing all functions used to write data to a file or files."""

import getpass
from datetime import datetime
from pathlib import Path
from typing import Union

import pytz
from docx import Document
from docx.opc.constants import RELATIONSHIP_TYPE
from docx.opc.exceptions import PackageNotFoundError
from docx.opc.oxml import qn
from docx.oxml import OxmlElement

from notes_converter.utils.constants import DATA_PATH, TEMPLATE_PATH
from notes_converter.utils.convert import build_study_references, extract_study_data
from notes_converter.utils.exceptions import NoAvailableTemplate
from notes_converter.utils.loaders import load_json


def write_to_txt(notes, output_path):
    """Write the given notes to a `.txt` file."""
    with open(output_path, "w", encoding="utf-8") as f:
        for note in notes:
            f.write("\n\n" + note.title + "\n")
            f.write(convert_datetime(note.created) + "\n\n")
            for body in note.note_text:
                f.write(body + " ")
            f.write("\n" + note.source_location)


def write_to_docx(
    notes,
    output_path: Union[str, Path],
    template_path: Union[str, Path, None],
):
    """Write notes to a styled Word document.

    Parameters
    ----------
    notes : A list of `note` objects.
    output_path : The location to save the Word document.
    template_path : A path to a Word document template.
        `None` means that the default template will be used.

    Returns
    -------
    A styled Word document in the given `output_path`.
    """
    # Is there a custom template path?
    if template_path:
        template = Path(template_path)
        valid_template = template.exists() and template.suffix == ".docx"
        if not valid_template:
            template = TEMPLATE_PATH / "default.docx"
    else:
        template = TEMPLATE_PATH / "default.docx"

    try:
        doc = Document(str(template))
    except PackageNotFoundError:
        # This error is raised only when default.docx is open in another
        # application. Aside from development, that should (in theory)
        # never happen in production.
        raise NoAvailableTemplate

    file_name = Path(output_path).stem

    # Clear existing template data
    doc._body.clear_content()
    doc.add_heading(file_name, level=0)

    for note in notes:
        doc.add_heading(note.title, level=1)
        doc.add_paragraph(convert_datetime(note.created), style="Date")

        for value, body in enumerate(note.note_text):
            if value == 0:  # Allow for no text indent on first paragraph.
                doc.add_paragraph(body, style="Head")
                continue
            doc.add_paragraph(body, style="Normal")

        # TODO: an add_run() will be needed to use Word's
        # built-in Hyperlink style. Can add_hyperlink() be
        # modified to use add_run() and to add the hyperlink
        # to that?

        # NOTE: Any note created directly in Annotations in the Gospel Library
        # app or Gospel Library Online will have an "undefined" source
        # location.
        if note.source_location == "undefined":
            reference = "Source: "
        else:
            # Build the source references using the source location URL.
            mapped_names = load_json(DATA_PATH / "data_maps.json")
            extracted_reference = extract_study_data(
                note.source_location,
                mapped_names,
            )
            reference = build_study_references(extracted_reference)

        p = doc.add_paragraph(style="Link")
        add_hyperlink(p, note.source_location, reference)

    # Add document properties
    doc.core_properties.author = getpass.getuser()
    doc.core_properties.comments = "Document generated by a script."

    doc.save(str(output_path))


# write_to_docx() helper functions


def convert_datetime(note_time: str) -> str:
    """Convert the time to a human-readable format."""
    default_time = datetime.fromisoformat(note_time.replace("Z", "+00:00"))
    dt = default_time.replace(tzinfo=pytz.utc)
    pacific_tz = pytz.timezone("America/Los_Angeles")
    dt_pacific = dt.astimezone(pacific_tz)
    return dt_pacific.strftime("%B %d, %Y, %I:%M %p %Z")


def add_hyperlink(paragraph, url, text, color="#0000EE", underline=None):
    """Place a hyperlink within a `paragraph` object.

    Parameters
    ----------
    paragraph : The `paragraph` object to which to add the hyperlink.
    url : A string containing a given url.
    text : The text displayed for the url.
    color : The color of the hyperlink.
    underline : Whether an underline is applied.

    Returns
    -------
    A `hyperlink` object with the hyperlink
    """
    # Get access to the document.xml.rels file and get a new relation id value:
    part = paragraph.part
    r_id = part.relate_to(
        url,
        RELATIONSHIP_TYPE.HYPERLINK,
        is_external=True,
    )

    # Create the w:hyperlink tag and add needed values:
    hyperlink = OxmlElement("w:hyperlink")
    hyperlink.set(qn("r:id"), r_id)

    # Create a w:r element:
    new_run = OxmlElement("w:r")

    # Create a w:rPr element:
    rPr = OxmlElement("w:rPr")

    # Add provided color (if any):
    if color:
        c = OxmlElement("w:color")
        c.set(qn("ct:val"), color)
        rPr.append(c)

    # Remove underline if requested:
    if underline:
        u = OxmlElement("w:u")
        u.set(qn("ct:val"), "single")
        rPr.append(u)
    else:
        u = OxmlElement("w:u")
        u.set(qn("ct:val"), "none")
        rPr.append(u)

    # Join all xml elements and add hyperlink text to w:r element:
    new_run.append(rPr)
    new_run.text = text
    hyperlink.append(new_run)

    paragraph._p.append(hyperlink)

    return hyperlink
